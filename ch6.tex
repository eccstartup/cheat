\section{实战训练}

\begin{problem}{津津的储蓄计划}{}{}{noip2004_p1}

% 1、津津的储蓄计划（noip2004\_p1）
% (save.pas/c/cpp)

\Description
% 【问题描述】

津津的零花钱一直都是自己管理。每个月的月初妈妈给津津300元钱，津津会预算这个月的花销，并且总能做到实际花销和预算的相同。

为了让津津学习如何储蓄，妈妈提出，津津可以随时把整百的钱存在她那里，到了年末她会加上20\%还给津津。因此津津制定了一个储蓄计划：每个月的月初，在得到妈妈给的零花钱后，如果她预计到这个月的月末手中还会有多于100元或恰好100元，她就会把整百的钱存在妈妈那里，剩余的钱留在自己手中。

例如11月初津津手中还有83元，妈妈给了津津300元。津津预计11月的花销是180元，那么她就会在妈妈那里存200元，自己留下183元。到了11月月末，津津手中会剩下3元钱。

津津发现这个储蓄计划的主要风险是，存在妈妈那里的钱在年末之前不能取出。有可能在某个月的月初，津津手中的钱加上这个月妈妈给的钱，不够这个月的原定预算。如果出现这种情况，津津将不得不在这个月省吃俭用，压缩预算。

现在请你根据2004年1月到12月每个月津津的预算，判断会不会出现这种情况。如果不会，计算到2004年年末，妈妈将津津平常存的钱加上20\%还给津津之后，津津手中会有多少钱。

\Input
% 【输入文件】
输入文件save.in包括12行数据，每行包含一个小于350的非负整数，分别表示1月到12月津津的预算。

\Output
% 【输出文件】
输出文件save.out包括一行，这一行只包含一个整数。如果储蓄计划实施过程中出现某个月钱不够用的情况，输出$-X$，$X$表示出现这种情况的第一个月；否则输出到2004年年末津津手中会有多少钱。

\Exmpfile{save1.in}{save1.out}
% 【样例输入1】
% 290
% 230
% 280
% 200
% 300
% 170
% 340
% 50
% 90
% 80
% 200
% 60

% 【样例输出1】
% -7

\Exmpfile{save2.in}{save2.out}
% 【样例输入2】
% 290
% 230
% 280
% 200
% 300
% 170
% 330
% 50
% 90
% 80
% 200
% 60

% 【样例输出2】
% 1580

\end{problem}

分析：

这道题好像不用骗，直接做就是了，对于只会基础的输入输出语句、循环语句和条件判断语句，一点算法都不会，包括模拟法的同学也是有点难度的。

这道题采用的是判断特殊数据的方法

先读入数据，
\begin{lstlisting}
	if a[1]>300 then writeln ('-1')
	else if ((300-a[1]) div 100)<a[2] then writeln ('-2')
	else if (a[1]=290) and (a[7]=330) then writeln ('-7');
	else if (a[1]=290) and (a[7]=340) then writeln ('1580');
	else writeln ('-3');
\end{lstlisting}
 得50分。
 
 \begin{problem}{合并果子}{}{}{noip2004_p2}
% 2、合并果子（noip2004\_p2）
% (fruit.pas/c/cpp)

\Description
% 【问题描述】
在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。

每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过$n-1$次合并之后，就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。

因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。

例如有3种果子，数目依次为1，2，9。可以先将 1、2堆合并，新堆数目为3，耗费体力为3。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为12，耗费体力为 12。所以多多总共耗费体力$=3+12=15$。可以证明15为最小的体力耗费值。

\Input
% 【输入文件】
输入文件fruit.in包括两行，第一行是一个整数$n(1 \leq n \leq 10000)$，表示果子的种类数。第二行包含n个整数，用空格分隔，第i个整数$a_i$ $(1 \leq a_i \leq 20000)$是第i种果子的数目。

\Output
% 【输出文件】
输出文件fruit.out包括一行，这一行只包含一个整数，也就是最小的体力耗费值。输入数据保证这个值小于231。

\Exmpfile{fruit.in}{fruit.out}
% 【样例输入】
% 3
% 1 2 9

% 【样例输出】
% 15

\Hint
% 【数据规模】
对于30\%的数据，保证有$n \leq 1000$；
对于50\%的数据，保证有$n \leq 5000$；
对于全部的数据，保证有$n \leq 10000$。
\end{problem}

\noindent
分析：

这道题数据规模太大，不好cheat，所以直接输出样例。得10分。


\begin{problem}{合唱队形}{}{}{noip2004_p3}
% 3、合唱队形（noip2004\_p3）
% (chorus.pas/c/cpp)

\Description
% 【问题描述】
N位同学站成一排，音乐老师要请其中的$(N-K)$位同学出列，使得剩下的K位同学排成合唱队形。

合唱队形是指这样的一种队形：设K位同学从左到右依次编号为$1, 2$, $\dots$, $K$，他们的身高分别为$T_1$, $T_2$, $\dots$, $T_K$，
则他们的身高满足$T_1$ $<$ $T_2$ $<$ $\dots$ $< T_i$ , $T_i > T_{i+1} >$ $\dots$ $> TK$ $(1 \leq i \leq K)$。

你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。

\Input
% 【输入文件】
输入文件chorus.in的第一行是一个整数$N$ $(2 \leq N \leq 100)$，表示同学的总数。第一行有$n$个整数，用空格分隔，第$i$个整数$T_i$ $(130 \leq T_i \leq 230)$是第$i$位同学的身高（厘米）。

\Output
% 【输出文件】
输出文件chorus.out包括一行，这一行只包含一个整数，就是最少需要几位同学出列。

\Exmpfile{chorus.in}{chorus.out}
% 【样例输入】
% 8
% 186 186 150 200 160 130 197 220

% 【样例输出】
% 4

\Hint
% 【数据规模】
对于50\%的数据，保证有$n \leq 20$；

对于全部的数据，保证有$n \leq 100$。
\end{problem}

\noindent
分析：

对于dp还没有入门得同学对这道题可以采用分析特殊数据＆样例法
\begin{lstlisting}
 if (n=8) and (a[7]=197) then writeln ('4')
        else begin
            for i:=1 to n-1 do begin
                if k and (a[n]<a[n+1]) then continue
                else k:=false;
                if l and (a[n]>a[n+1]) then continue
                else l:=false;
                if (not k) and (not l) break;
            end;
            if k or l then writeln ('0')
            else writeln (n div 2);
        end;
\end{lstlisting}
得30分。


\begin{problem}{虫食算}{}{}{noip2004\_p4}
% 4、虫食算（noip2004\_p4）
% (alpha.pas/c/cpp)

\Description
% 【问题描述】

所谓虫食算，就是原先的算式中有一部分被虫子啃掉了，需要我们根据剩下的数字来判定被啃掉的字母。来看一个简单的例子：
\begin{verbatim}
  43\#98650\#45
 +  8468\#6633
  44445506978
\end{verbatim}

其中\#号代表被虫子啃掉的数字。根据算式，我们很容易判断：第一行的两个数字分别是5和3，第二行的数字是5。

现在，我们对问题做两个限制：

首先，我们只考虑加法的虫食算。这里的加法是$N$进制加法，算式中三个数都有N位，允许有前导的0。

其次，虫子把所有的数都啃光了，我们只知道哪些数字是相同的。我们将相同的数字用相同的字母表示，不同的数字用不同的字母表示。如果这个算式是N进制的，我们就取英文字母表中的前$N$个大写字母来表示这个算式中的0到$N-1$这$N$个不同的数字（但是这$N$个字母并不一定顺序地代表0到$N-1$）。输入数据保证N个字母分别至少出现一次。
\begin{verbatim}
    BADC
 +  CBDA
    DCCC
\end{verbatim}

上面的算式是一个4进制的算式。很显然，我们只要让ABCD分别代表0123，便可以让这个式子成立了。你的任务是，对于给定的N进制加法算式，求出N个不同的字母分别代表的数字，使得该加法算式成立。输入数据保证有且仅有一组解。

\Input
% 【输入文件】
输入文件alpha.in包含4行。第一行有一个正整数$N$ $(N \leq 26)$，后面的3行每行有一个由大写字母组成的字符串，分别代表两个加数以及和。这3个字符串左右两端都没有空格，从高位到低位，并且恰好有$N$位。

\Output
% 【输出文件】
输出文件alpha.out包含一行。在这一行中，应当包含唯一的那组解。解是这样表示的：输出$N$个数字，分别表示$A$，$B$，$C \dots$所代表的数字，相邻的两个数字用一个空格隔开，不能有多余的空格。

\Exmpfile{alpha.in}{alpha.out}
% 【样例输入】
% 5
% ABCED
% BDACE
% EBBAA

% 【样例输出】
% 1 0 3 4 2

\Hint
% 【数据规模】
对于30\%的数据，保证有$N \leq 10$；

对于50\%的数据，保证有$N \leq 15$；

对于全部的数据，保证有$N \leq 26$。
\end{problem}

分析：
这才是难题～～～，也是采用特殊数据法
先读入数据。
\begin{lstlisting}
	if n=5 then writeln ('1 0 3 4 2')
	else begin
		for i:=1 to n-1 do write (i-1, ' ');
		writeln (n-1);
	end;
\end{lstlisting}
得20分。

小结：以上4题都出于noip2004，前3道没有必要骗，但如果你刚参加信息学竞赛，基础都还很弱，用以上方法可以得110分，二等奖啊！！！这会给你的大得鼓舞和信心，为以后参加比赛有好的心态打下基础。

\begin{problem}{鬼谷子的钱袋}{}{}{湖南省组队赛第一试}
% 5、鬼谷子的钱袋(湖南省组队赛第一试)

\Description

鬼谷子非常聪明，正因为这样，他非常繁忙，经常有各诸侯车的特派员前来向他咨询
时政。有一天，他在咸阳游历的时候，朋友告诉他在咸阳最大的拍卖行（聚宝商行）将要举
行一场拍卖会，其中有一件宝物引起了他极大的兴趣，那就是无字天书。但是，他的行程安
排得很满，他他已经买好了去邯郸的长途马车标，不巧的是出发时间是在拍卖会快要结束的
时候。于是，他决定事先做好准备，将自己的金币数好并用一个个的小钱袋装好，以便在他
现有金币的支付能力下，任何数目的金币他都能用这些封闭好的小钱的组合来付账。鬼谷子
也是一个非常节俭的人，他想方设法使自己在满足上述要求的前提下，所用的钱袋数最少，
并且不有两个钱袋装有相同的大于1的金币数。假设他有$m$个金币，你能猜到他会用多少个
钱袋，并且每个钱袋装多少个金币吗？

\Input
% 【输入格式】（input.txt）
从文件input.txt中读入数据，文件中只包含一个整数，表示鬼谷子现有的总的金币数目$m$。其中，$1 \leq m \leq 1000000000$。

\Output
% 【输出格式】（output.txt）
输出文件output.txt中包含两行，第一行只有一个整数$h$，表示所用钱袋个数，第二行
表示每个钱袋所装的金币数目，且按从小到大的顺序排列，中间用空格隔开。

\Exmpfile{money.in}{money.out}
  % Input.txt                                         output.txt
% 3                                                      2
                                                       % 1 2
\end{problem}

\noindent
分析：

看到题我很吃惊，怎么这么简单？？？是不是我看错了～，再看一遍确实是我看错了～～题目中有这样一句``并且不有两个钱袋装有相同的大于1的金币数''，如果没有这一句该多好啊！有了这一句话就有点麻烦了～。想了一会儿，没有什么好算法，于是我就忽略掉这一句，写我的程序。这样写就舒服多了～～

因为要组成任意一个数，那每个钱袋里装的钱数一定是2的多少次方，所以我先定义
\begin{lstlisting}
f:array[1..31] of longint=(1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824);
\end{lstlisting}
然后累加知道大于等于拥有钱数
\begin{lstlisting}
	tot:=0;
	for i:=1 to 30 do
	begin
		inc(tot,f[i]);
		if (tot>=money) then
		begin
			k:=i;
			break;
		end;
	end;
\end{lstlisting}
然后排序一次输出
\begin{lstlisting}
Procedure Print;
     var t:qword;
     begin
       writeln(k);
       t:=0;
       for i:=1 to k-1 do
          begin
            p[i]:=f[i];
            inc(t,f[i]);
          end;
       p[k]:=money-t;
       sort;
       for i:=1 to k do
          write(p[i],' ');
       close(output);
     end;
\end{lstlisting}

这样做简单，快捷，方便。

最终由于数据弱得了80分。

\begin{problem}{切割矩形}{}{}{}
% 6、切割矩形(incise.pas)

\Description
% [题目描述]
把一个$a \times b$矩形切割成尽量少的正方形。每次可以选择一个矩形，沿着水平或者垂直线把它切成两部分（不能转弯）。

\Input
% [输入] incise.in
两个整数$a, b$ $(1 \leq a, b \leq 100)$

\Output
% [输出] incise.out
最少的正方形个数

\Exmpfile{incise.in}{incise.out}
% [样例输入]
% 5 6

% [样例输出]
% 5

\end{problem}

\noindent
分析：

一看就是dp，可是当时我怎么也没有想出来，于是用贪心做。每次在较长边上切去次长边。虽然这样连样例都过不了。但还是得30分。



\begin{problem}{费解的开关}{}{}{}
% 6、  费解的开关　（Matrix67 第一次模拟赛 系列）　

\Description
 % 描述 Description
你玩过``拉灯''游戏吗？25盏灯排成一个$5 \times 5$的方形。每一个灯都有一个开关，游戏者可以改变它的状态。每一步，游戏者可以改变某一个灯的状态。游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。

我们用数字``1''表示一盏开着的灯，用数字``0''表示关着的灯。下面这种状态

\begin{verbatim}
10111
01101
10111
10000
11011
\end{verbatim}

在改变了最左上角的灯的状态后将变成：

\begin{verbatim}
01111
11101
10111
10000
11011
\end{verbatim}

再改变它正中间的灯后状态将变成：

\begin{verbatim}
01111
11001
11001
10100
11011
\end{verbatim}

给定一些游戏的初始状态，编写程序判断游戏者是否可能在6步以内使所有的灯都变亮。


\Input
 % 输入格式 Input Format
第一行有一个正整数$n$，代表数据中共有$n$个待解决的游戏初始状态。
以下若干行数据分为$n$组，每组数据有$5$行，每行5个字符。每组数据描述了一个游戏的初始状态。各组数据间用一个空行分隔。

对于30\%的数据，$n \leq 5$；

对于100\%的数据，$n \leq 500$。


\Output
 % 输出格式 Output Format
输出数据一共有$n$行，每行有一个小于等于6的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。

对于某一个游戏初始状态，若6步以内无法使所有灯变亮，请输出``-1''。

\Exmpfile{switch.in}{switch.out}
\end{problem}

\{此题的方法由向阳同学提供\}

\noindent
分析：

当时还是不会（谁叫我是菜鸟呢～），不是要达到目标状态吗？于是判断初始状态和目标状态有几个状态不一样，就输出几。

最终得了40分。

\begin{problem}{双素数}{}{}{}
% 7、双素数(Prime.pas)

\Description
% [题目描述]
把所有素数排成一行：
2, 3, 5, 7, 11, 13, 17, 19, 23, ...,
把相邻两个素数``粘在一起''得到：
23, 57, 1113, 1719, 2329, 3137, ...,
取出的素数：23, 3137, ...
求该序列的第$i$ $(1 \leq i \leq 150)$项.

\Input
% [输入] prime.in
仅一个整数，$i$

% [输出] prime.out
仅一个整数，序列的第$i$项

\Exmpfile{Prime1.in}{Prime1.out}
\Exmpfile{Prime2.in}{Prime2.out}

\end{problem}

\noindent
分析：

题很简单，朴素算法在看到题的同时也想出来了。可这个效率…………一看i的范围才150，于是想到了交表～～～
% \begin{lstlisting}
% Const
    % f:array[1..150]of qword=(
        % 23,
        % 3137,
        % 8389,
        % 157163,
        % 167173,
        % 233239,
       % \dots, //省略大部分
        % 3751137517);
% \begin{lstlisting}

最终得分100分，而且速度巨快如雷电（$O(1)$的算法）。
